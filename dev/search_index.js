var documenterSearchIndex = {"docs":
[{"location":"QHO/#Quantum-Harmonic-Oscillators","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"","category":"section"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"In this section, we describe symbolic representations of bosonic systems in QuantumSymbolics, which can be numerically translated to QuantumOptics.jl.","category":"page"},{"location":"QHO/#States","page":"Quantum Harmonic Oscillators","title":"States","text":"","category":"section"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"A Fock state is a state with well defined number of excitation quanta of a single quantum harmonic oscillator (an eigenstate of the number operator). In the following example, we create a FockState with 3 quanta in an infinite-dimension Fock space:","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"julia> f = FockState(3)\n|3⟩","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Both vacuum (ground) and single-photon states are defined as constants in both unicode and ASCII for convenience:","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"vac = F₀ = F0 =0rangle in the number state representation,\nF₁ = F1 =1rangle in the number state representation.","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"To create quantum analogues of a classical harmonic oscillator, or monochromatic electromagnetic waves, we can define a coherent (a.k.a. semi-classical) state alpharangle, where alpha is a complex amplitude, with CoherentState:","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"julia> c = CoherentState(im)\n|im⟩","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"note: Naming convention for quantum harmonic oscillator bases\nThe defined basis for arbitrary symbolic bosonic states is a FockBasis object, due to a shared naming interface for Quantum physics packages. For instance, the command basis(CoherentState(im)) will output Fock(cutoff=Inf). This may lead to confusion, as not all bosonic states are Fock states. However, this is simply a naming convention for the basis, and symbolic and numerical results are not affected by it.","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Summarized below are supported bosonic states.","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Fock state: FockState(idx::Int),\nCoherent state: CoherentState(alpha::Number),\nSqueezed vacuum state: SqueezedState(z::Number).","category":"page"},{"location":"QHO/#Operators","page":"Quantum Harmonic Oscillators","title":"Operators","text":"","category":"section"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Operations on bosonic states are supported, and can be simplified with qsimplify and its rewriter qsimplify_fock. For instance, we can apply the raising (creation) hata^dagger and lowering (annihilation or destroy) hata operators on a Fock state as follows:","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"julia> f = FockState(3);\n\njulia> raise = Create*f\na†|3⟩\n\njulia> qsimplify(raise, rewriter=qsimplify_fock)\n(sqrt(4))|4⟩\n\njulia> lower = Destroy*f\na|3⟩\n\njulia> qsimplify(lower, rewriter=qsimplify_fock)\n(sqrt(3))|2⟩","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Or, we can apply the number operator hatn to our Fock state:","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"julia> f = FockState(3);\n\njulia> num = N*f\nn|3⟩\n\njulia> qsimplify(num, rewriter=qsimplify_fock)\n3|3⟩","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Constants are defined for number and ladder operators in unicode and ASCII:","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"N = n̂ =hatn,\nCreate = âꜛ =hata^dagger,\nDestroy = â =hata.","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Phase-shift U(theta) and displacement D(alpha) operators, defined respectively as","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"U(theta) = expleft(-ithetahatnright) quad textand quad D(alpha) = expleft(alphahata^dagger - alphahataright)","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"can be defined with usual simplification rules. Consider the following example:","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"julia> displace = DisplaceOp(im)\nD(im)\n\njulia> c = qsimplify(displace*vac, rewriter=qsimplify_fock)\n|im⟩\n\njulia> phase = PhaseShiftOp(pi)\nU(π)\n\njulia> qsimplify(phase*c, rewriter=qsimplify_fock)\n|1.2246467991473532e-16 - 1.0im⟩","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Here, we generated a coherent state irangle from the vacuum state 0rangle by applying the displacement operator defined by DisplaceOp. Then, we shifted its phase by pi with the phase shift operator (which is called with PhaseShiftOp) to get the result -irangle.","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Summarized below are supported bosonic operators.","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Number operator: NumberOp(),\nCreation operator: CreateOp(),\nAnnihilation operator: DestroyOp(),\nPhase-shift operator: PhaseShiftOp(phase::Number),\nDisplacement operator: DisplaceOp(alpha::Number),\nSqueezing operator: SqueezeOp(z::Number).","category":"page"},{"location":"QHO/#Numerical-Conversions-to-QuantumOptics.jl","page":"Quantum Harmonic Oscillators","title":"Numerical Conversions to QuantumOptics.jl","text":"","category":"section"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"Bosonic systems can be translated to the ket representation with express. For instance:","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"julia> f = FockState(1);\n\njulia> express(f)\nKet(dim=3)\n  basis: Fock(cutoff=2)\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n\njulia> express(Create) |> dense\nOperator(dim=3x3)\n  basis: Fock(cutoff=2)\n 0.0+0.0im      0.0+0.0im  0.0+0.0im\n 1.0+0.0im      0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.41421+0.0im  0.0+0.0im\n\njulia> express(Create*f)\nKet(dim=3)\n  basis: Fock(cutoff=2)\n                0.0 + 0.0im\n                0.0 + 0.0im\n 1.4142135623730951 + 0.0im\n\njulia> express(Destroy*f)\nKet(dim=3)\n  basis: Fock(cutoff=2)\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"warning: Cutoff specifications for numerical representations of quantum harmonic oscillators\nSymbolic bosonic states and operators are naturally represented in an infinite dimension basis. For numerical conversions of such quantum objects, a finite cutoff of the highest allowed state must be defined. By default, the basis dimension of numerical conversions is set to 3 (so the number representation cutoff is 2), as demonstrated above. To define a different cutoff, one must customize the QuantumOpticsRepr instance, e.g. provide QuantumOpticsRepr(cutoff=n::Int) to express.","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"If we wish to specify a different numerical cutoff, say 4, to the previous examples, then we rewrite them as follows:","category":"page"},{"location":"QHO/","page":"Quantum Harmonic Oscillators","title":"Quantum Harmonic Oscillators","text":"julia> f = FockState(1);\n\njulia> express(f, QuantumOpticsRepr(cutoff=4))\nKet(dim=5)\n  basis: Fock(cutoff=4)\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\njulia> express(Create, QuantumOpticsRepr(4)) |> dense\nOperator(dim=5x5)\n  basis: Fock(cutoff=4)\n 0.0+0.0im      0.0+0.0im      0.0+0.0im  0.0+0.0im  0.0+0.0im\n 1.0+0.0im      0.0+0.0im      0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.41421+0.0im      0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im      0.0+0.0im  1.73205+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im      0.0+0.0im      0.0+0.0im  2.0+0.0im  0.0+0.0im","category":"page"},{"location":"introduction/#Getting-Started-with-QuantumSymbolics.jl","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"","category":"section"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"QuantumSymbolics is designed for manipulation and numerical translation of symbolic quantum objects. This tutorial introduces basic features of the package.","category":"page"},{"location":"introduction/#Installation","page":"Getting Started with QuantumSymbolics.jl","title":"Installation","text":"","category":"section"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"QuantumSymbolics.jl can be installed through the Julia package system in the standard way:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"using Pkg\nPkg.add(\"QuantumSymbolics\")","category":"page"},{"location":"introduction/#Literal-Symbolic-Quantum-Objects","page":"Getting Started with QuantumSymbolics.jl","title":"Literal Symbolic Quantum Objects","text":"","category":"section"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Basic objects of type SBra, SKet, SOperator, and SSuperOperator represent symbolic quantum objects with name and basis properties. Each type can be generated with a straightforward macro:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> using QuantumSymbolics\n\njulia> @bra b # object of type SBra\n⟨b|\n\njulia> @ket k # object of type SKet\n|k⟩\n\njulia> @op A # object of type SOperator\nA\n\njulia> @superop S # object of type SSuperOperator\nS","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"By default, each of the above macros defines a symbolic quantum object in the spin-1/2 basis. One can simply choose a different basis, such as the Fock basis or a tensor product of several bases, by passing an object of type Basis to the second argument in the macro call:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> @op B FockBasis(Inf, 0.0)\nB\n\njulia> basis(B)\nFock(cutoff=Inf)\n\njulia> @op C SpinBasis(1//2)⊗SpinBasis(5//2)\nC\n\njulia> basis(C)\n[Spin(1/2) ⊗ Spin(5/2)]","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Here, we extracted the basis of the defined symbolic operators using the basis function.","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Symbolic quantum objects with additional properties can be defined, such as a Hermitian operator, or the zero ket (i.e., a symbolic ket equivalent to the zero vector bm0).","category":"page"},{"location":"introduction/#Basic-Operations","page":"Getting Started with QuantumSymbolics.jl","title":"Basic Operations","text":"","category":"section"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Expressions containing symbolic quantum objects can be built with a variety of functions. Let us consider the most fundamental operations: multiplication *, addition +, and the tensor product ⊗. ","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"We can multiply, for example, a ket by a scalar value, or apply an operator to a ket:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> @ket k; @op A;\n\njulia> 2*k\n2|k⟩\n\njulia> A*k\nA|k⟩","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Similar scaling procedures can be performed on bras and operators. Addition between symbolic objects is also available, for instance:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> @op A₁; @op A₂;\n\njulia> A₁+A₂\nA₁+A₂\n\njulia> @bra b;\n\njulia> 2*b + 5*b\n7⟨b|","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Built into the package are straightforward automatic simplification rules, as shown in the last example, where 2⟨b|+5⟨b| evaluates to 7⟨b|. ","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Tensor products of symbolic objects can be performed, with basis information transferred:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> @ket k₁; @ket k₂;\n\njulia> tp = k₁⊗k₂\n|k₁⟩|k₂⟩\n\njulia> basis(tp)\n[Spin(1/2) ⊗ Spin(1/2)]","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Inner and outer products of bras and kets can be generated:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> @bra b; @ket k;\n\njulia> b*k\n⟨b||k⟩\n\njulia> k*b\n|k⟩⟨b|","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"More involved combinations of operations can be explored. Here are few other straightforward examples:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> @bra b; @ket k; @op A; @op B;\n\njulia> 3*A*B*k\n3AB|k⟩\n\njulia> A⊗(k*b + B)\nA⊗(B+|k⟩⟨b|)\n\njulia> A-A\n𝟎","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"In the last example, a zero operator, denoted 𝟎, was returned by subtracting a symbolic operator from itself. Such an object is of the type SZeroOperator, and similar objects SZeroBra and SZeroKet correspond to zero bras and zero kets, respectively.","category":"page"},{"location":"introduction/#Linear-Algebra-on-Bras,-Kets,-and-Operators","page":"Getting Started with QuantumSymbolics.jl","title":"Linear Algebra on Bras, Kets, and Operators","text":"","category":"section"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"QuantumSymbolics supports a wide variety of linear algebra on symbolic bras, kets, and operators. For instance, the commutator and anticommutator of two operators, can be generated:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> @op A; @op B;\n\njulia> commutator(A, B)\n[A,B]\n\njulia> anticommutator(A, B)\n{A,B}\n\njulia> commutator(A, A)\n𝟎","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Or, one can take the dagger of a quantum object with the dagger function:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> @ket k; @op A; @op B;\n\njulia> dagger(A)\nA†\n\njulia> dagger(A*k)\n|k⟩†A†\n\njulia> dagger(A*B)\nB†A†","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Below, we state all of the supported linear algebra operations on quantum objects:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"commutator of two operators: commutator,\nanticommutator of two operators: anticommutator,\ncomplex conjugate: conj,\ntranspose: transpose,\nprojection of a ket: projector,\nadjoint or dagger: dagger,\ntrace: tr,\npartial trace: ptrace,\ninverse of an operator: inv,\nexponential of an operator: exp,\nvectorization of an operator: vec.","category":"page"},{"location":"introduction/#Predefined-Quantum-Objects","page":"Getting Started with QuantumSymbolics.jl","title":"Predefined Quantum Objects","text":"","category":"section"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"So far in this tutorial, we have considered arbitrary kets, bras, operators, and their corresponding operations. This package supports predefined quantum objects and operations in several formalisms, which are discussed in detail in other sections (see, for example, the quantum harmonic oscillators or qubit basis pages). To get a taste of what's available, let us consider a few symbolic examples. For a complete description, see the full API page.","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Quantum gates and their basis states can be represented symbolically:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> CNOT # CNOT Gate\nCNOT\n\njulia> X, Y, Z, I # Pauli operators\n(X, Y, Z, 𝕀)\n\njulia> X1, X2 # Eigenstates of the Pauli X operator\n(|X₁⟩, |X₂⟩)\n\njulia> CPHASE * (Z1 ⊗ Z2) # Application of CPHASE gate on |01⟩\nCPHASE|Z₁⟩|Z₂⟩","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"We also have symbolic representations of bosonic systems:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> FockState(4) # Fock state with 4 excitation quanta\n|4⟩\n\njulia> Create, Destroy # creation and annihilation operators\n(a†, a)\n\njulia> DisplaceOp(im) # Displacement operator for single bosonic mode\nD(im)\n\njulia> N * vac # Application of number operator on vacuum state\nn|0⟩","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"If we want to substitute a predefined quantum object into a general symbolic expression, we can use the substitute command from Symbolics.jl:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> using Symbolics\n\njulia> @op A; @ket k;\n\njulia> ex = 2*A + projector(k)\n2A+𝐏[|k⟩]\n\njulia> substitute(ex, Dict([A => X, k => X1]))\n2X+𝐏[|X₁⟩]","category":"page"},{"location":"introduction/#Simplifying-Expressions","page":"Getting Started with QuantumSymbolics.jl","title":"Simplifying Expressions","text":"","category":"section"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"For predefined objects such as the Pauli operators X, Y, and Z, additional simplification can be performed with the qsimplify function. Take the following example:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> qsimplify(X*Z)\n(0 - 1im)Y","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Here, we have the relation XZ = -iY, so calling qsimplify on the expression X*Z will rewrite the expression as -im*Y.","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Note that simplification rewriters used in QuantumSymbolics are built from the interface of SymbolicUtils.jl. By default, when called on an expression, qsimplify will iterate through every defined simplification rule in the QuantumSymbolics package until the expression can no longer be simplified. ","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Now, suppose we only want to use a specific subset of rules. For instance, say we wish to simplify commutators, but not anticommutators. Then, we can pass the keyword argument rewriter=qsimplify_commutator to qsimplify, as done in the following example:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> qsimplify(commutator(X, Y), rewriter=qsimplify_commutator)\n(0 + 2im)Z\n\njulia> qsimplify(anticommutator(X, Y), rewriter=qsimplify_commutator)\n{X,Y}","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"As shown above, we apply qsimplify to two expressions: commutator(X, Y) and anticommutator(X, Y). We specify that only commutator rules will be applied, thus the first expression is rewritten to (0 + 2im)Z while the second expression is simply returned. This feature can greatly reduce the time it takes for an expression to be simplified.","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Below, we state all of the simplification rule subsets that can be passed to qsimplify:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"qsimplify_pauli for Pauli multiplication,\nqsimplify_commutator for commutators of Pauli operators,\nqsimplify_anticommutator for anticommutators of Pauli operators.","category":"page"},{"location":"introduction/#Expanding-Expressions","page":"Getting Started with QuantumSymbolics.jl","title":"Expanding Expressions","text":"","category":"section"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Symbolic expressions containing quantum objects can be expanded with the qexpand function. We demonstrate this capability with the following examples.","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> @op A; @op B; @op C;\n\njulia> qexpand(A⊗(B+C))\n(A⊗B)+(A⊗C)\n\njulia> qexpand((B+C)*A)\nBA+CA\n\njulia> @ket k₁; @ket k₂; @ket k₃;\n\njulia> qexpand(k₁⊗(k₂+k₃))\n|k₁⟩|k₂⟩+|k₁⟩|k₃⟩\n\njulia> qexpand((A*B)*(k₁+k₂))\nAB|k₁⟩+AB|k₂⟩","category":"page"},{"location":"introduction/#Numerical-Translation-of-Symbolic-Objects","page":"Getting Started with QuantumSymbolics.jl","title":"Numerical Translation of Symbolic Objects","text":"","category":"section"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"Symbolic expressions containing predefined objects can be converted to numerical representations with express. Numerics packages supported by this translation capability are QuantumOptics.jl and QuantumClifford.jl.","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"By default, express converts an object to the quantum optics state vector representation. For instance, we can represent the exponential of the Pauli operator X numerically as follows:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> using QuantumOptics\n\njulia> express(exp(X))\nOperator(dim=2x2)\n  basis: Spin(1/2)\n 1.5430806327160496 + 0.0im  1.1752011684303352 + 0.0im\n 1.1752011684303352 + 0.0im  1.5430806327160496 + 0.0im","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"To convert to the Clifford representation, an instance of CliffordRepr must be passed to express. For instance, we can represent the projection of the basis state X1 of the Pauli operator X as follows:","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"julia> using QuantumClifford\n\njulia> express(projector(X1), CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n+ X","category":"page"},{"location":"introduction/","page":"Getting Started with QuantumSymbolics.jl","title":"Getting Started with QuantumSymbolics.jl","text":"For more details on using express, refer to the express functionality page.","category":"page"},{"location":"express/#Express-functionality","page":"Express Functionality","title":"Express functionality","text":"","category":"section"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"A principle feature of QuantumSymbolics is to numerically represent symbolic quantum expressions in various formalisms using express. In particular, one can translate symbolic logic to back-end toolboxes such as QuantumOptics.jl or QuantumClifford.jl for simulating quantum systems with great flexibility.","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"As a straightforward example, consider the spin-up state uparrowrangle = 0rangle, the eigenstate of the Pauli operator Z, which can be expressed in QuantumSymbolics as follows:","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"using QuantumSymbolics, QuantumClifford, QuantumOptics # hide\nψ = Z1","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"Using express, we can translate this symbolic object into its numerical state vector form in QuantumOptics.jl.","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"express(ψ)","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"By default, express converts a quantum object with QuantumOpticRepr. It should be noted that express automatically caches this particular conversion of ψ. Thus, after running the above example, the numerical representation of the spin-up state is stored in the metadata of ψ.","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"ψ.metadata","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"The caching feature of express prevents a specific representation for a symbolic quantum object from being computed more than once. This becomes handy for translations of more complex operations, which can become computationally expensive. We also have the ability to express Z_1rangle in the Clifford formalism with QuantumClifford.jl:","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"express(ψ, CliffordRepr())","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"Here, we specified an instance of CliffordRepr in the second argument to convert ψ into a tableau of Pauli operators containing its stabilizer and destabilizer states. Now, both the state vector and Clifford representation of ψ have been cached:","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"ψ.metadata","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"More involved examples can be explored. For instance, say we want to apply the tensor product Xotimes Y of the Pauli operators X and Y to the Bell state Phi^+rangle = dfrac1sqrt2left(00rangle + 11rangleright), and numerically express the result in the quantum optics formalism. This would be done as follows:","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"using QuantumSymbolics, QuantumClifford, QuantumOptics # hide\nbellstate = (Z1⊗Z1+Z2⊗Z2)/√2\ntp = σˣ⊗σʸ\nexpress(tp*bellstate)","category":"page"},{"location":"express/#Examples-of-Edge-Cases","page":"Express Functionality","title":"Examples of Edge Cases","text":"","category":"section"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"For Pauli operators, additional flexibility is given for translations to the Clifford formalism. Users have the option to convert a multi-qubit Pauli operator to an observable or operation with instances of UseAsObservable and UseAsOperation, respectively. Take the Pauli operator Y, for example, which in QuantumSymbolics is the constants Y or σʸ:","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"julia> express(σʸ, CliffordRepr(), UseAsObservable())\n+ Y\n\njulia> express(σʸ, CliffordRepr(), UseAsOperation())\nsY","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"Another edge case is translations with QuantumOpticsRepr, where we can additionally define a finite cutoff for bosonic states and operators, as discussed in the quantum harmonic oscillators page. The default cutoff for such objects is 2, however a different cutoff can be specified by passing an integer to QuantumOpticsRepr in an express call. Let us see an example with the number operator:","category":"page"},{"location":"express/","page":"Express Functionality","title":"Express Functionality","text":"julia> express(N) |> dense\nOperator(dim=3x3)\n  basis: Fock(cutoff=2)\n 0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  2.0+0.0im\n\njulia> express(N, QuantumOpticsRepr(cutoff=4)) |> dense\nOperator(dim=5x5)\n  basis: Fock(cutoff=4)\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  2.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  3.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  4.0+0.0im","category":"page"},{"location":"qubit_basis/#Typical-Qubit-Bases","page":"Qubit Basis Choice","title":"Typical Qubit Bases","text":"","category":"section"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"Here are some common conventions for representing a qubit in a physical system. This reference is provided as the conventions matter to the correct choice of noise processes and bases in which they are represented.","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"In monospaced code format we give the symbols by which these objects are callable in QuantumSymbolics. We provide unicode and ASCII names for convenience of typing.","category":"page"},{"location":"qubit_basis/#Spin-\\frac{1}{2}-qubits","page":"Qubit Basis Choice","title":"Spin frac12 qubits","text":"","category":"section"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"First we introduce the Pauli matrices:","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"julia> express(σᶻ) |> dense # or `Z`\nOperator(dim=2x2)\n  basis: Spin(1/2)\n 1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im\n\njulia> express(σˣ) |> dense # or `X`\nOperator(dim=2x2)\n  basis: Spin(1/2)\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im\n\njulia> express(σʸ) |> dense # or `Y`\nOperator(dim=2x2)\n  basis: Spin(1/2)\n 0.0+0.0im  -0.0-1.0im\n 0.0+1.0im   0.0+0.0im","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"Above dense is from QuantumOptics, used to convert their representation to a dense matrix.","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"The eigenvectors of each one of them provides for a convenient basis. The σᶻ basis is also called the computational basis. As mentioned, we have both unicode and ASCII names for convenience of typing. For these basis vectors we also have two sets of names: one based on which operator they are eigenvectors of and one in terms of typical logical representation (with prefix L).","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"Z1 = Z₁ = L0 = L₀ = 0rangle = beginpmatrix10endpmatrix = uparrowrangle with eigenvalue +1 for σᶻ\nZ2 = Z₂ = L1 = L₁ = 1rangle = beginpmatrix01endpmatrix = downarrowrangle with eigenvalue +1 for σᶻ\nX1 = X₁ = Lp = L₊ = +rangle = frac1sqrt 2beginpmatrix11endpmatrix with eigenvalue +1 for σˣ\nX2 = X₂ = Lm = L₋ = -rangle = frac1sqrt 2beginpmatrix1-1endpmatrix with eigenvalue -1 for σˣ\nY1 = Y₁ = Lpi = L₊ᵢ = +irangle = frac1sqrt 2beginpmatrix1 iendpmatrix with eigenvalue +1 for σʸ\nY2 = Y₂ = Lmi = L₋ᵢ = -irangle = frac1sqrt 2beginpmatrix1-iendpmatrix with eigenvalue -1 for σʸ","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"The Y vectors occasionally are denoted with R and L (stemming from the vector notation for right and left polarized light), but there is no established notation choice or ordering.","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"warning: Talking about ground/excited and spin-up/spin-down states can lead to confusion\nWe specifically avoid using notation with \"ground\" and \"excited\" states. For physicist usually the excited state is the \"up\" states (erangle=uparrowrangle), but that historical choice clashes with the logical state notation as we have the logical zero be the \"excited\" state. This clash becomes particularly confusing when noise processes and relaxation process are taken into account. E.g. one might think the operator usually denoted hatsigma_- would be the one corresponding to decay but we actually have hatsigma_-0rangle=1rangle. To avoid this confusion we strive to not use the notation uparrowrangle, downarrowrangle, erangle, and grangle. Similarly we strongly prefer to never use hatsigma_- and hatsigma_+, rather only use 1rangle langle0 and its conjugate. If we were instead talking about single-rail photonic qubits, we do not have the same issue (because the diagonal of the number operator is growing, instead of decreasing like the diagonal of the Pauli Z).","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"The basis states can be easily expressed both as kets and as tableaux (In the tableau representation below the top half corresponds to the destabilizer, while the bottom is the stabilizer):","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"julia> express(L0, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X\n𝒮𝓉𝒶𝒷\n+ Z\n\n\njulia> express(L1, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X\n𝒮𝓉𝒶𝒷\n- Z\n\n\njulia> express(L₀, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X\n𝒮𝓉𝒶𝒷\n+ Z\n\n\njulia> express(L₁, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ X\n𝒮𝓉𝒶𝒷\n- Z\n\n\njulia> express(L₊, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n+ X\n\n\njulia> express(L₋, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- X\n\n\njulia> express(L₊ᵢ, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n+ Y\n\n\njulia> express(L₋ᵢ, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n- Y","category":"page"},{"location":"qubit_basis/","page":"Qubit Basis Choice","title":"Qubit Basis Choice","text":"julia> express(L₀)\nKet(dim=2)\n  basis: Spin(1/2)\n 1.0 + 0.0im\n 0.0 + 0.0im\n\njulia> express(L₁)\nKet(dim=2)\n  basis: Spin(1/2)\n 0.0 + 0.0im\n 1.0 + 0.0im\n\njulia> express(L₊)\nKet(dim=2)\n  basis: Spin(1/2)\n 0.7071067811865475 + 0.0im\n 0.7071067811865475 + 0.0im\n\njulia> express(L₋)\nKet(dim=2)\n  basis: Spin(1/2)\n  0.7071067811865475 + 0.0im\n -0.7071067811865475 + 0.0im\n\njulia> express(L₊ᵢ)\nKet(dim=2)\n  basis: Spin(1/2)\n 0.7071067811865475 + 0.0im\n                0.0 + 0.7071067811865475im\n\njulia> express(L₋ᵢ)\nKet(dim=2)\n  basis: Spin(1/2)\n 0.7071067811865475 + 0.0im\n                0.0 - 0.7071067811865475im","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"#QuantumSymbolics.jl","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"","category":"section"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"A symbolics package for quantum information science. It serves two purposes:","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"It provides for algebraic manipulation of mathematical expressions related to your quantum models. Particularly helpful when having to automatically generate or simplify expressions of significant complexity.\nAn assortment of \"expression translators\" are provided that can turn a symbolic expression into a numerical one in a variety of formalisms.","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"Below we list some commonly used expressions, followed by an autogenerated API list.","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"<table>\n<tr>\n<th></th><th>Symbolic Example</th><th>Conversion Example</th>\n</tr>\n<tr>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"<!-- Qubit Basis States -->\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"Qubit Basis States X1, X2, Y1, Y2, Z1, Z2","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"Z1","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(Z1)","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(Y2, CliffordRepr())","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"<!-- Common gates -->\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"Common gates: CNOT, H, etc","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"CNOT","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(H)","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(CNOT, CliffordRepr(), UseAsOperation())","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"<!-- Tensor products and sums -->\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"Tensor products ⊗ and sums +","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"(X1⊗Z2 + Y1⊗Y2 ) / √3","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(X1⊗Z1)","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(X1⊗Y2, CliffordRepr())","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"<!-- Projectors -->\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"Projectors, pure density matrices","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"SProjector(X1⊗Z2)","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(SProjector(X1⊗Z1))","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(SProjector(X1⊗Z1), CliffordRepr())","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"<!-- Completely mixed state -->\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"Completely depolarized (mixed) state","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"MixedState(X1)","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(MixedState(X1))","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(MixedState(X1), CliffordRepr())","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"<!-- Mixtures -->\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"Impure states, represented as sum of density matrices","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"(MixedState(X1)+SProjector(Z1)) / 2","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n<td>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express((MixedState(X1)+SProjector(Z1)) / 2)","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"When a Clifford representation is used, an efficient sampler is generated, and stabilizer states are randomly sampled from the correct distribution:","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"express(MixedState(X1)/2+SProjector(Z1)/2, CliffordRepr())","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</td>\n</tr>\n<tr>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"</tr>\n</table>","category":"page"},{"location":"","page":"QuantumSymbolics.jl","title":"QuantumSymbolics.jl","text":"warning: Stabilizer state expressions\nThe state written as fracZ₁Z₁+Z₂Z₂2 is a well known stabilizer state, namely a Bell state. However, automatically expressing it as a stabilizer is a prohibitively expensive computational operation in general. We do not perform that computation automatically. If you want to ensure that states you define can be automatically converted to tableaux for Clifford simulations, avoid using summation of kets. On the other hand, in all of our Clifford Monte-Carlo simulations, ⊗ is fully supported, as well as projector, MixedState, StabilizerState, and summation of density matrices.","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/#QuantumSymbolics.CNOT","page":"API","title":"QuantumSymbolics.CNOT","text":"CNOT gate\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.CPHASE","page":"API","title":"QuantumSymbolics.CPHASE","text":"CPHASE gate\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Create","page":"API","title":"QuantumSymbolics.Create","text":"Creation operator, also available as the constant âꜛ, in an infinite dimension Fock basis. There is no unicode dagger superscript, so we use the uparrow\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Destroy","page":"API","title":"QuantumSymbolics.Destroy","text":"Annihilation operator, also available as the constant â, in an infinite dimension Fock basis.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.F₁","page":"API","title":"QuantumSymbolics.F₁","text":"Single photon state\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.H","page":"API","title":"QuantumSymbolics.H","text":"Hadamard gate\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.I","page":"API","title":"QuantumSymbolics.I","text":"Identity operator in qubit basis\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.N","page":"API","title":"QuantumSymbolics.N","text":"Number operator, also available as the constant n̂, in an infinite dimension Fock basis.\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Pm","page":"API","title":"QuantumSymbolics.Pm","text":"Pauli \"minus\" operator, also available as the constant σ₋\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Pp","page":"API","title":"QuantumSymbolics.Pp","text":"Pauli \"plus\" operator, also available as the constant σ₊\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.X","page":"API","title":"QuantumSymbolics.X","text":"Pauli X operator, also available as the constant σˣ\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.X1","page":"API","title":"QuantumSymbolics.X1","text":"Basis state of σˣ\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.X2","page":"API","title":"QuantumSymbolics.X2","text":"Basis state of σˣ\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Y","page":"API","title":"QuantumSymbolics.Y","text":"Pauli Y operator, also available as the constant σʸ\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Y1","page":"API","title":"QuantumSymbolics.Y1","text":"Basis state of σʸ\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Y2","page":"API","title":"QuantumSymbolics.Y2","text":"Basis state of σʸ\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Z","page":"API","title":"QuantumSymbolics.Z","text":"Pauli Z operator, also available as the constant σᶻ\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Z1","page":"API","title":"QuantumSymbolics.Z1","text":"Basis state of σᶻ\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.Z2","page":"API","title":"QuantumSymbolics.Z2","text":"Basis state of σᶻ\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.vac","page":"API","title":"QuantumSymbolics.vac","text":"Single-mode vacuum state\n\n\n\n\n\n","category":"constant"},{"location":"API/#QuantumSymbolics.AmplifierCPTP","page":"API","title":"QuantumSymbolics.AmplifierCPTP","text":"AmplifierCPTP(r::Number, noise::Int)\n\nAmplification CPTP map, defined by the squeezing amplitude parameter r and thermal noise parameter noise.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.AttenuatorCPTP","page":"API","title":"QuantumSymbolics.AttenuatorCPTP","text":"AttenuatorCPTP(theta::Number, noise::Int)\n\nAttenuation CPTP map, defined by the beam splitter rotation parameter theta and thermal noise parameter noise.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.BeamSplitterOp","page":"API","title":"QuantumSymbolics.BeamSplitterOp","text":"Two-mode beamsplitter operator in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.BosonicThermalState","page":"API","title":"QuantumSymbolics.BosonicThermalState","text":"Thermal bosonic state in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.CoherentState","page":"API","title":"QuantumSymbolics.CoherentState","text":"Coherent state in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.CreateOp","page":"API","title":"QuantumSymbolics.CreateOp","text":"Creation (raising) operator.\n\njulia> f = FockState(2)\n|2⟩\n\njulia> create = CreateOp()\na†\n\njulia> qsimplify(create*f, rewriter=qsimplify_fock)\n(sqrt(3))|3⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.DephasingCPTP","page":"API","title":"QuantumSymbolics.DephasingCPTP","text":"Single-qubit dephasing CPTP map\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.DestroyOp","page":"API","title":"QuantumSymbolics.DestroyOp","text":"Annihilation (lowering or destroy) operator in defined Fock basis.\n\njulia> f = FockState(2)\n|2⟩\n\njulia> destroy = DestroyOp()\na\n\njulia> qsimplify(destroy*f, rewriter=qsimplify_fock)\n(sqrt(2))|1⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.DisplaceOp","page":"API","title":"QuantumSymbolics.DisplaceOp","text":"Displacement operator in defined Fock basis.\n\njulia> f = FockState(0)\n|0⟩\n\njulia> displace = DisplaceOp(im)\nD(im)\n\njulia> qsimplify(displace*f, rewriter=qsimplify_fock)\n|im⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.FockState","page":"API","title":"QuantumSymbolics.FockState","text":"Fock state in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.GateCPTP","page":"API","title":"QuantumSymbolics.GateCPTP","text":"A unitary gate followed by a CPTP map\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.IdentityOp","page":"API","title":"QuantumSymbolics.IdentityOp","text":"The identity operator for a given basis\n\njulia> IdentityOp(X1⊗X2)\n𝕀\n\njulia> express(IdentityOp(Z2))\nOperator(dim=2x2)\n  basis: Spin(1/2)sparse([1, 2], [1, 2], ComplexF64[1.0 + 0.0im, 1.0 + 0.0im], 2, 2)\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.KrausRepr","page":"API","title":"QuantumSymbolics.KrausRepr","text":"Kraus representation of a quantum channel\n\njulia> @op A₁; @op A₂; @op A₃;\n\njulia> K = kraus(A₁, A₂, A₃)\n𝒦(A₁,A₂,A₃)\n\njulia> @op ρ;\n\njulia> K*ρ\nA₁ρA₁†+A₂ρA₂†+A₃ρA₃†\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.MixedState","page":"API","title":"QuantumSymbolics.MixedState","text":"Completely depolarized state\n\njulia> MixedState(X1⊗X2)\n𝕄\n\njulia> express(MixedState(X1⊗X2))\nOperator(dim=4x4)\n  basis: [Spin(1/2) ⊗ Spin(1/2)]\n 0.25 + 0.0im        ⋅             ⋅             ⋅     \n       ⋅       0.25 + 0.0im        ⋅             ⋅\n       ⋅             ⋅       0.25 + 0.0im        ⋅\n       ⋅             ⋅             ⋅       0.25 + 0.0im\n\njulia> express(MixedState(X1⊗X2), CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n \n𝒳ₗ━━\n+ X_\n+ _X\n𝒮𝓉𝒶𝒷\n \n𝒵ₗ━━\n+ Z_\n+ _Z\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.NumberOp","page":"API","title":"QuantumSymbolics.NumberOp","text":"Number operator.\n\njulia> f = FockState(2)\n|2⟩\n\njulia> num = NumberOp()\nn\n\njulia> qsimplify(num*f, rewriter=qsimplify_fock)\n2|2⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.PauliNoiseCPTP","page":"API","title":"QuantumSymbolics.PauliNoiseCPTP","text":"Single-qubit Pauli noise CPTP map\n\njulia> apply!(express(Z1), [1], express(PauliNoiseCPTP(1/4,1/4,1/4)))\nOperator(dim=2x2)\n  basis: Spin(1/2)\n 0.5+0.0im  0.0+0.0im\n 0.0+0.0im  0.5+0.0im\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.PhaseShiftOp","page":"API","title":"QuantumSymbolics.PhaseShiftOp","text":"Phase-shift operator in defined Fock basis.\n\njulia> c = CoherentState(im)\n|im⟩\n\njulia> phase = PhaseShiftOp(pi)\nU(π)\n\njulia> qsimplify(phase*c, rewriter=qsimplify_fock)\n|1.2246467991473532e-16 - 1.0im⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SAdd","page":"API","title":"QuantumSymbolics.SAdd","text":"Addition of quantum objects (kets, operators, or bras).\n\njulia> @ket k₁; @ket k₂;\n\njulia> k₁ + k₂\n|k₁⟩+|k₂⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SAnticommutator","page":"API","title":"QuantumSymbolics.SAnticommutator","text":"Symbolic anticommutator of two operators.\n\njulia> @op A; @op B;\n\njulia> anticommutator(A, B)\n{A,B}\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SApplyBra","page":"API","title":"QuantumSymbolics.SApplyBra","text":"Symbolic application of an operator on a bra (from the right).\n\njulia> @bra b; @op A;\n\njulia> b*A\n⟨b|A\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SApplyKet","page":"API","title":"QuantumSymbolics.SApplyKet","text":"Symbolic application of an operator on a ket (from the left).\n\njulia> @ket k; @op A;\n\njulia> A*k\nA|k⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SBra","page":"API","title":"QuantumSymbolics.SBra","text":"Symbolic bra\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SBraKet","page":"API","title":"QuantumSymbolics.SBraKet","text":"Symbolic inner product of a bra and a ket.\n\njulia> @bra b; @ket k;\n\njulia> b*k\n⟨b||k⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SCommutator","page":"API","title":"QuantumSymbolics.SCommutator","text":"Symbolic commutator of two operators.\n\njulia> @op A; @op B;\n\njulia> commutator(A, B)\n[A,B]\n\njulia> commutator(A, A)\n𝟎\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SConjugate","page":"API","title":"QuantumSymbolics.SConjugate","text":"Complex conjugate of quantum objects (kets, bras, operators).\n\njulia> @op A; @ket k;\n\njulia> conj(A)\nAˣ\n\njulia> conj(k)\n|k⟩ˣ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SDagger","page":"API","title":"QuantumSymbolics.SDagger","text":"Dagger, i.e., adjoint of quantum objects (kets, bras, operators).\n\njulia> @ket a; @op A;\n\njulia> dagger(2*im*A*a)\n(0 - 2im)|a⟩†A†\n\njulia> @op B;\n\njulia> dagger(A*B)\nB†A†\n\njulia> ℋ = SHermitianOperator(:ℋ); U = SUnitaryOperator(:U);\n\njulia> dagger(ℋ)\nℋ\n\njulia> dagger(U)\nU⁻¹\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SExpOperator","page":"API","title":"QuantumSymbolics.SExpOperator","text":"Exponential of a symbolic operator.\n\njulia> @op A; @op B;\n\njulia> exp(A)\nexp(A)\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SHermitianOperator","page":"API","title":"QuantumSymbolics.SHermitianOperator","text":"Symbolic Hermitian operator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SHermitianUnitaryOperator","page":"API","title":"QuantumSymbolics.SHermitianUnitaryOperator","text":"Symbolic Hermitian and unitary operator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SInvOperator","page":"API","title":"QuantumSymbolics.SInvOperator","text":"Inverse of an operator.\n\njulia> @op A;\n\njulia> inv(A)\nA⁻¹\n\njulia> inv(A)*A\n𝕀\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SKet","page":"API","title":"QuantumSymbolics.SKet","text":"Symbolic ket\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SMulOperator","page":"API","title":"QuantumSymbolics.SMulOperator","text":"Symbolic application of operator on operator.\n\njulia> @op A; @op B;\n\njulia> A*B\nAB\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SOperator","page":"API","title":"QuantumSymbolics.SOperator","text":"Symbolic operator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SOuterKetBra","page":"API","title":"QuantumSymbolics.SOuterKetBra","text":"Symbolic outer product of a ket and a bra.\n\njulia> @bra b; @ket k;\n\njulia> k*b \n|k⟩⟨b|\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SPartialTrace","page":"API","title":"QuantumSymbolics.SPartialTrace","text":"Partial trace over system i of a composite quantum system\n\njulia> @op 𝒪 SpinBasis(1//2)⊗SpinBasis(1//2);\n\njulia> op = ptrace(𝒪, 1)\ntr1(𝒪)\n\njulia> QuantumSymbolics.basis(op)\nSpin(1/2)\n\njulia> @op A; @op B;\n\njulia> ptrace(A⊗B, 1)\n(tr(A))B\n\njulia> @ket k; @bra b;\n\njulia> factorizable = A ⊗ (k*b)\nA⊗|k⟩⟨b|\n\njulia> ptrace(factorizable, 1)\n(tr(A))|k⟩⟨b|\n\njulia> ptrace(factorizable, 2)\n(⟨b||k⟩)A\n\njulia> mixed_state = (A⊗(k*b)) + ((k*b)⊗B)\n(A⊗|k⟩⟨b|)+(|k⟩⟨b|⊗B)\n\njulia> ptrace(mixed_state, 1)\n(0 + ⟨b||k⟩)B+(tr(A))|k⟩⟨b|\n\njulia> ptrace(mixed_state, 2)\n(0 + ⟨b||k⟩)A+(tr(B))|k⟩⟨b|\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SProjector","page":"API","title":"QuantumSymbolics.SProjector","text":"Projector for a given ket.\n\njulia> projector(X1⊗X2)\n𝐏[|X₁⟩|X₂⟩]\n\njulia> express(projector(X2))\nOperator(dim=2x2)\n  basis: Spin(1/2)\n  0.5+0.0im  -0.5-0.0im\n -0.5+0.0im   0.5+0.0im\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SScaled","page":"API","title":"QuantumSymbolics.SScaled","text":"Scaling of a quantum object (ket, operator, or bra) by a number.\n\njulia> @ket k\n|k⟩\n\njulia> 2*k\n2|k⟩\n\njulia> @op A\nA\n\njulia> 2*A\n2A\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SSuperOpApply","page":"API","title":"QuantumSymbolics.SSuperOpApply","text":"Symbolic application of a superoperator on an operator\n\njulia> @op A; @superop S;\n\njulia> S*A\nS[A]\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SSuperOperator","page":"API","title":"QuantumSymbolics.SSuperOperator","text":"Symbolic superoperator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.STrace","page":"API","title":"QuantumSymbolics.STrace","text":"Trace of an operator\n\njulia> @op A; @op B;\n\njulia> tr(A)\ntr(A)\n\njulia> tr(commutator(A, B))\n0\n\njulia> @bra b; @ket k;\n\njulia> tr(k*b)\n⟨b||k⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.STranspose","page":"API","title":"QuantumSymbolics.STranspose","text":"Transpose of quantum objects (kets, bras, operators).\n\njulia> @op A; @op B; @ket k;\n\njulia> transpose(A)\nAᵀ\n\njulia> transpose(A+B)\nAᵀ+Bᵀ\n\njulia> transpose(k)\n|k⟩ᵀ\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SUnitaryOperator","page":"API","title":"QuantumSymbolics.SUnitaryOperator","text":"Symbolic unitary operator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SVec","page":"API","title":"QuantumSymbolics.SVec","text":"Vectorization of a symbolic operator.\n\njulia> @op A; @op B;\n\njulia> vec(A)\n|A⟩⟩\n\njulia> vec(A+B)\n|A⟩⟩+|B⟩⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SZeroBra","page":"API","title":"QuantumSymbolics.SZeroBra","text":"Symbolic zero bra\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SZeroKet","page":"API","title":"QuantumSymbolics.SZeroKet","text":"Symbolic zero ket\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SZeroOperator","page":"API","title":"QuantumSymbolics.SZeroOperator","text":"Symbolic zero operator\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SqueezeOp","page":"API","title":"QuantumSymbolics.SqueezeOp","text":"Squeezing operator in defined Fock basis.\n\njulia> S = SqueezeOp(pi)\nS(π)\n\njulia> qsimplify(S*vac, rewriter=qsimplify_fock)\n|0,π⟩\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.SqueezedState","page":"API","title":"QuantumSymbolics.SqueezedState","text":"Squeezed vacuum state in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.StabilizerState","page":"API","title":"QuantumSymbolics.StabilizerState","text":"State defined by a stabilizer tableau\n\nFor full functionality you also need to import the QuantumClifford library.\n\njulia> using QuantumClifford, QuantumOptics # needed for the internal representation of the stabilizer tableaux and the conversion to a ket\n\njulia> StabilizerState(S\"XX ZZ\")\n𝒮₂\n\njulia> express(StabilizerState(S\"-X\"))\nKet(dim=2)\n  basis: Spin(1/2)\n  0.7071067811865475 + 0.0im\n -0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.TwoSqueezeOp","page":"API","title":"QuantumSymbolics.TwoSqueezeOp","text":"Two-mode squeezing operator in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API/#QuantumSymbolics.TwoSqueezedState","page":"API","title":"QuantumSymbolics.TwoSqueezedState","text":"Two-mode squeezed vacuum state, or EPR state, in defined Fock basis.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.conj-Union{Tuple{SymbolicUtils.Symbolic{T}}, Tuple{T}} where T<:Union{QuantumInterface.AbstractBra, QuantumInterface.AbstractKet, QuantumInterface.AbstractOperator, QuantumInterface.AbstractSuperOperator}","page":"API","title":"Base.conj","text":"conj(x::Symbolic{AbstractKet})\nconj(x::Symbolic{AbstractBra})\nconj(x::Symbolic{AbstractOperator})\nconj(x::Symbolic{AbstractSuperOperator})\n\nSymbolic complex conjugate operation. See also SConjugate.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.exp-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"API","title":"Base.exp","text":"exp(x::Symbolic{AbstractOperator})\n\nSymbolic exponential of an operator. See also SExpOperator.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.inv-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"API","title":"Base.inv","text":"inv(x::Symbolic{AbstractOperator})\n\nSymbolic inverse of an operator. See also SInvOperator.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.transpose-Union{Tuple{SymbolicUtils.Symbolic{T}}, Tuple{T}} where T<:Union{QuantumInterface.AbstractBra, QuantumInterface.AbstractKet, QuantumInterface.AbstractOperator}","page":"API","title":"Base.transpose","text":"transpose(x::Symbolic{AbstractKet})\ntranspose(x::Symbolic{AbstractBra})\ntranspose(x::Symbolic{AbstractOperator})\n\nSymbolic transpose operation. See also STranspose.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.vec-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"API","title":"Base.vec","text":"vec(x::Symbolic{AbstractOperator})\n\nSymbolic vector representation of an operator. See also SVec.\n\n\n\n\n\n","category":"method"},{"location":"API/#LinearAlgebra.tr-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"API","title":"LinearAlgebra.tr","text":"tr(x::Symbolic{AbstractOperator})\n\nSymbolic trace operation. See also STrace.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.dagger-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractBra}}","page":"API","title":"QuantumInterface.dagger","text":"dagger(x::Symbolic{AbstractBra})\n\nSymbolic adjoint operation. See also SDagger.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.dagger-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractKet}}","page":"API","title":"QuantumInterface.dagger","text":"dagger(x::Symbolic{AbstractKet})\n\nSymbolic adjoint operation. See also SDagger.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.dagger-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}}","page":"API","title":"QuantumInterface.dagger","text":"dagger(x::Symbolic{AbstractOperator})\n\nSymbolic adjoint operation. See also SDagger.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.express-Tuple{SymbolicUtils.Symbolic, AbstractRepresentation, AbstractUse}","page":"API","title":"QuantumInterface.express","text":"express(s, repr::AbstractRepresentation=QuantumOpticsRepr()[, use::AbstractUse])\n\nThe main interface for expressing symbolic quantum objects in various representations.\n\njulia> express(X1)\nKet(dim=2)\n  basis: Spin(1/2)\n 0.7071067811865475 + 0.0im\n 0.7071067811865475 + 0.0im\n\njulia> express(X1, CliffordRepr())\n𝒟ℯ𝓈𝓉𝒶𝒷\n+ Z\n𝒮𝓉𝒶𝒷\n+ X\n\njulia> express(QuantumSymbolics.X)\nOperator(dim=2x2)\n  basis: Spin(1/2)\n      ⋅       1.0 + 0.0im\n 1.0 + 0.0im       ⋅\n\njulia> express(QuantumSymbolics.X, CliffordRepr(), UseAsOperation())\nsX\n\njulia> express(QuantumSymbolics.X, CliffordRepr(), UseAsObservable())\n+ X\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.projector-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractKet}}","page":"API","title":"QuantumInterface.projector","text":"projector(x::Symbolic{AbstractKet})\n\nSymbolic projection operation. See also SProjector.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.ptrace-Tuple{SymbolicUtils.Symbolic{QuantumInterface.AbstractOperator}, Any}","page":"API","title":"QuantumInterface.ptrace","text":"ptrace(x::Symbolic{AbstractOperator})\n\nSymbolic partial trace operation. See also SPartialTrace.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSymbolics.anticommutator","page":"API","title":"QuantumSymbolics.anticommutator","text":"The anticommutator of two operators.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSymbolics.commutator","page":"API","title":"QuantumSymbolics.commutator","text":"The commutator of two operators.\n\n\n\n\n\n","category":"function"},{"location":"API/#QuantumSymbolics.consistent_representation-Tuple{Any, Any}","page":"API","title":"QuantumSymbolics.consistent_representation","text":"Pick a representation that is consistent with given representations and appropriate for the given state.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSymbolics.qexpand-Tuple{Any}","page":"API","title":"QuantumSymbolics.qexpand","text":"qexpand(s)\n\nManually expand a symbolic expression of quantum objects. \n\njulia> @op A; @op B; @op C;\n\njulia> qexpand(commutator(A, B))\n-1BA+AB\n\njulia> qexpand(A⊗(B+C))\n(A⊗B)+(A⊗C)\n\njulia> @ket k₁; @ket k₂;\n\njulia> qexpand(A*(k₁+k₂))\nA|k₁⟩+A|k₂⟩\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSymbolics.qsimplify-Tuple{Any}","page":"API","title":"QuantumSymbolics.qsimplify","text":"qsimplify(s; rewriter=nothing)\n\nManually simplify a symbolic expression of quantum objects. \n\nIf the keyword rewriter is not specified, then qsimplify will apply every defined rule to the expression.  For performance or single-purpose motivations, the user has the option to define a specific rewriter for qsimplify to apply to the expression. The defined rewriters for simplification are the following objects:     - qsimplify_pauli     - qsimplify_commutator     - qsimplify_anticommutator     - qsimplify_fock\n\njulia> qsimplify(σʸ*commutator(σˣ*σᶻ, σᶻ))\n(0 - 2im)Z\n\njulia> qsimplify(anticommutator(σˣ, σˣ), rewriter=qsimplify_anticommutator)\n2𝕀\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumSymbolics.@bra-Tuple{Any, Any}","page":"API","title":"QuantumSymbolics.@bra","text":"@bra(name, basis=SpinBasis(1//2))\n\nDefine a symbolic bra of type SBra. By default, the defined basis is the spin-1/2 basis.\n\njulia> @bra b₁\n⟨b₁|\n\njulia> @bra b₂ FockBasis(2)\n⟨b₂|\n\n\n\n\n\n","category":"macro"},{"location":"API/#QuantumSymbolics.@ket-Tuple{Any, Any}","page":"API","title":"QuantumSymbolics.@ket","text":"@ket(name, basis=SpinBasis(1//2))\n\nDefine a symbolic ket of type SKet. By default, the defined basis is the spin-1/2 basis.\n\njulia> @ket k₁\n|k₁⟩\n\njulia> @ket k₂ FockBasis(2)\n|k₂⟩\n\n\n\n\n\n","category":"macro"},{"location":"API/#QuantumSymbolics.@op-Tuple{Any, Any}","page":"API","title":"QuantumSymbolics.@op","text":"@op(name, basis=SpinBasis(1//2))\n\nDefine a symbolic operator of type SOperator. By default, the defined basis is the spin-1/2 basis.\n\njulia> @op A\nA\n\njulia> @op B FockBasis(2)\nB\n\n\n\n\n\n","category":"macro"}]
}
